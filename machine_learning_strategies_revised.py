import numpy as np
import pandas as pd
import yfinance as yf
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.impute import SimpleImputer
from xgboost import XGBRegressor


def download_stock_data(tickers, start_date, end_date):
    """
    Downloads stock data using yfinance.
    Returns Adjusted Close prices as a DataFrame.
    """
    data = yf.download(tickers, start=start_date, end=end_date, progress=False, auto_adjust=False)
    adj_close = data['Adj Close']

    # Handle single ticker
    if isinstance(tickers, str):
        if isinstance(adj_close, pd.Series):
            adj_close = adj_close.to_frame()
        adj_close.columns = ['Adj Close']
    else:
        adj_close.columns = [f"{col}_Adj Close" for col in adj_close.columns]

    return adj_close


def create_additional_features(stock_data):
    """
    Adds moving averages, volatility, forward returns, Bollinger Bands, and drawdown.
    Returns a DataFrame suitable for ML.
    """
    df = stock_data.copy()
    df['20d_rolling_avg'] = df['Adj Close'].rolling(20).mean()
    df['40d_rolling_avg'] = df['Adj Close'].rolling(40).mean()
    
    # Forward returns
    df['5d_forward_return'] = df['Adj Close'].shift(-5) / df['Adj Close'] - 1
    df['10d_forward_return'] = df['Adj Close'].shift(-10) / df['Adj Close'] - 1
    
    # Volatility
    df['30d_volatility'] = df['Adj Close'].pct_change().rolling(30).std()
    df['30d_volatility_lag_1'] = df['30d_volatility'].shift(1)
    
    # Bollinger Band Width
    rolling_mean_40 = df['Adj Close'].rolling(40).mean()
    rolling_std_40 = df['Adj Close'].rolling(40).std()
    df['Bollinger_Band_Width'] = (2 * rolling_std_40) / rolling_mean_40
    
    # Drawdown
    df['drawdown'] = df['Adj Close'] / df['Adj Close'].rolling(40).max() - 1

    # Remove intermediate volatility
    df.drop(columns=['30d_volatility'], inplace=True)

    # Drop rows with NaNs generated by rolling/shifting
    df.dropna(inplace=True)

    return df


def prepare_data_for_ml(stock_data, lag_days=20):
    """
    Prepares lagged features for ML model.
    """
    df = stock_data.copy() if isinstance(stock_data, pd.DataFrame) else pd.DataFrame(stock_data, columns=['Adj Close'])
    target_column = 'Adj Close'

    for i in range(1, lag_days + 1):
        df[f'lag_{i}'] = df[target_column].shift(i)

    df.dropna(inplace=True)
    return df


def train_model(model, X_train, y_train):
    model.fit(X_train, y_train)
    return model


def get_model_confidence(model, X_test, y_test):
    """
    Uses R^2 as confidence metric.
    """
    return model.score(X_test, y_test)


def predict_future_returns(model, stock_data):
    """
    Predicts future price and returns.
    """
    if isinstance(stock_data, pd.DataFrame):
        prepared_data = prepare_data_for_ml(stock_data)
        features = prepared_data.drop('Adj Close', axis=1)
    else:
        features = stock_data

    # Impute missing values
    imputer = SimpleImputer(strategy='mean')
    features = imputer.fit_transform(features)

    # Standardize features
    scaler = StandardScaler()
    features_scaled = scaler.fit_transform(features)

    # Predict
    predictions = model.predict(features_scaled)
    return predictions[-1]  # return last predicted value


def generate_investor_views(ticker, start_date, end_date, model_type='XGBoost', forward_days=20):
    """
    Generates predicted forward returns and confidence for a stock.
    """
    stock_data = download_stock_data(ticker, start_date, end_date)
    stock_data_ml = create_additional_features(stock_data)

    if stock_data_ml.empty:
        return 0.0, 0.0  # safe fallback

    X = stock_data_ml.drop('Adj Close', axis=1)
    y = stock_data_ml['Adj Close']

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Impute missing values
    imputer = SimpleImputer(strategy='mean')
    X_train = imputer.fit_transform(X_train)
    X_test = imputer.transform(X_test)

    # Select model
    if model_type == 'Random Forest':
        model = RandomForestRegressor(n_estimators=100, random_state=42)
    elif model_type == 'Gradient Boosting':
        model = GradientBoostingRegressor(n_estimators=100, random_state=42)
    elif model_type == 'Linear Regression':
        model = LinearRegression()
    elif model_type == 'XGBoost':
        model = XGBRegressor(n_estimators=100, random_state=42, verbosity=0)
    else:
        raise ValueError("Invalid model type")

    trained_model = train_model(model, X_train, y_train)

    predicted_price = predict_future_returns(trained_model, X_test)
    last_price = stock_data_ml['Adj Close'].iloc[-1]
    predicted_return = (predicted_price / last_price - 1.0) if last_price != 0 else 0.0

    confidence = get_model_confidence(trained_model, X_test, y_test)

    # Ensure numeric outputs
    predicted_return = float(predicted_return)
    confidence = float(confidence)

    return predicted_return, confidence
